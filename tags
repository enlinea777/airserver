!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.7	//
AIRAPI_H	airapi.h	2;"	d
BUFF_HPP	buff.hpp	2;"	d
BufBlock_t	buff.hpp	/^struct BufBlock_t {$/;"	s
BufHead_t	buff.hpp	/^struct BufHead_t {$/;"	s
BufPool	buff.cpp	/^BufPool::BufPool()$/;"	f	class:BufPool
BufPool	buff.hpp	/^class BufPool {$/;"	c
CLEAR_BLOCK	buff.hpp	15;"	d
CRASH_BLOCK	buff.hpp	13;"	d
CYCLE_WAIT_NANO_SEC	workthread.hpp	7;"	d
DATA_BLOCK	buff.hpp	12;"	d
FIN_BLOCK	buff.hpp	14;"	d
GLOBAL_DATA_HPP	global_data.hpp	2;"	d
HANDLER_H	handler.hpp	2;"	d
HandlerBase	handler.hpp	/^class HandlerBase {$/;"	c
IP	main.cpp	20;"	d	file:
LOCK_HPP	lock.hpp	2;"	d
MutexLock	lock.cpp	/^MutexLock::MutexLock() {$/;"	f	class:MutexLock
MutexLock	lock.hpp	/^class MutexLock {$/;"	c
PAGE_SIZE	buff.hpp	10;"	d
PORT	main.cpp	19;"	d	file:
QUEUE_HPP	queue.hpp	2;"	d
Queue	queue.cpp	/^Queue<T>::Queue(int size) {$/;"	f	class:Queue
Queue	queue.hpp	/^template <class T> class Queue {$/;"	c
REACTOR_H	reactor.hpp	2;"	d
Reactor	reactor.cpp	/^Reactor::Reactor() {$/;"	f	class:Reactor
Reactor	reactor.hpp	/^class Reactor$/;"	c
Skinfo_t	airapi.h	/^struct Skinfo_t {$/;"	s
TCPACCEPT_HPP	tcpaccept.hpp	2;"	d
TCPSOCKETPOOL_HPP	tcpsocketpool.hpp	2;"	d
TCPSOCKET_HPP	tcpsocket.hpp	2;"	d
TIMEOUT	main.cpp	21;"	d	file:
TcpAccept	tcpaccept.cpp	/^TcpAccept::TcpAccept(Reactor &reactor)$/;"	f	class:TcpAccept
TcpAccept	tcpaccept.hpp	/^class TcpAccept : public HandlerBase {$/;"	c
TcpSocket	tcpsocket.cpp	/^TcpSocket::TcpSocket(Reactor &reactor)$/;"	f	class:TcpSocket
TcpSocket	tcpsocket.hpp	/^class TcpSocket : public HandlerBase$/;"	c
TcpSocketPool	tcpsocketpool.cpp	/^TcpSocketPool::TcpSocketPool(){$/;"	f	class:TcpSocketPool
TcpSocketPool	tcpsocketpool.hpp	/^class TcpSocketPool {$/;"	c
Thread	workthread.hpp	/^} Thread;$/;"	t	typeref:struct:__anon1
WORK_THREAD_HPP	workthread.hpp	2;"	d
WORK_THREAD_NUM	main.cpp	23;"	d	file:
alloc	buff.cpp	/^BufBlock_t* BufPool::alloc(uint32_t length) {$/;"	f	class:BufPool
buf_head	buff.hpp	/^    BufHead_t buf_head;$/;"	m	struct:BufBlock_t
buf_type	buff.hpp	/^    uint32_t buf_type;$/;"	m	struct:BufHead_t
check_timeout	handler.hpp	/^    virtual void check_timeout() {};$/;"	f	class:HandlerBase
check_timeout	tcpsocket.cpp	/^void TcpSocket::check_timeout() {$/;"	f	class:TcpSocket
create	tcpsocketpool.cpp	/^TcpSocket* TcpSocketPool::create(Reactor &reactor) {$/;"	f	class:TcpSocketPool
create_work_thread	workthread.hpp	/^void create_work_thread(int i) {$/;"	f
dll	airapi.h	/^dll_func_t dll;$/;"	v
dll_func_struct	airapi.h	/^typedef struct dll_func_struct {$/;"	s
dll_func_t	airapi.h	/^} dll_func_t;$/;"	t	typeref:struct:dll_func_struct
fini	reactor.cpp	/^bool Reactor::fini() {$/;"	f	class:Reactor
free	buff.cpp	/^void BufPool::free(BufBlock_t* block) {$/;"	f	class:BufPool
front	queue.cpp	/^T Queue<T>::front() {$/;"	f	class:Queue
g_receive_lock	global_data.cpp	/^MutexLock g_receive_lock;$/;"	v
g_receive_queue	global_data.cpp	/^Queue<BufBlock_t*> g_receive_queue;  \/\/接受队列$/;"	v
g_send_lock	global_data.cpp	/^MutexLock g_send_lock;$/;"	v
g_send_queue	global_data.cpp	/^Queue<BufBlock_t*> g_send_queue;     \/\/发送队列$/;"	v
get_curtime	reactor.hpp	/^    inline time_t get_curtime() {return m_curtime;}$/;"	f	class:Reactor
get_handler	reactor.cpp	/^HandlerBase* Reactor::get_handler(int fd) {$/;"	f	class:Reactor
handle	airapi.h	/^    void  *handle;$/;"	m	struct:dll_func_struct
handle_ctl	reactor.cpp	/^bool Reactor::handle_ctl(int fd, int op, uint32_t events_mask) {$/;"	f	class:Reactor
handle_error	tcpaccept.cpp	/^void TcpAccept::handle_error() {$/;"	f	class:TcpAccept
handle_error	tcpsocket.cpp	/^void TcpSocket::handle_error() {$/;"	f	class:TcpSocket
handle_events	reactor.cpp	/^void Reactor::handle_events(int timeout) {$/;"	f	class:Reactor
handle_input	airapi.h	/^    int (*handle_input) (const char*, int, const Skinfo_t*);$/;"	m	struct:dll_func_struct
handle_input	tcpaccept.cpp	/^bool TcpAccept::handle_input() {$/;"	f	class:TcpAccept
handle_input	tcpsocket.cpp	/^bool TcpSocket::handle_input() {$/;"	f	class:TcpSocket
handle_output	tcpaccept.cpp	/^bool TcpAccept::handle_output() {$/;"	f	class:TcpAccept
handle_output	tcpsocket.cpp	/^bool TcpSocket::handle_output() {$/;"	f	class:TcpSocket
handle_process	airapi.h	/^    int (*handle_process) (char*, int, char**, int*, const Skinfo_t*);$/;"	m	struct:dll_func_struct
handle_size	reactor.hpp	/^    inline int handle_size() {return m_size;}$/;"	f	class:Reactor
id	buff.hpp	/^    int id;$/;"	m	struct:BufHead_t
init	reactor.cpp	/^bool Reactor::init(int size) {$/;"	f	class:Reactor
key	buff.hpp	/^    uint32_t key;$/;"	m	struct:BufHead_t
len	buff.hpp	/^    uint32_t len;$/;"	m	struct:BufHead_t
len2page_size	buff.hpp	/^    inline uint32_t len2page_size(uint32_t length) {$/;"	f	class:BufPool
local_ip	airapi.h	/^    uint32_t local_ip;$/;"	m	struct:Skinfo_t
local_port	airapi.h	/^    uint16_t local_port;$/;"	m	struct:Skinfo_t
lock	lock.cpp	/^void MutexLock::lock() {$/;"	f	class:MutexLock
m_conn_timeout	tcpsocket.hpp	/^    uint32_t m_conn_timeout;$/;"	m	class:TcpSocket
m_count	queue.hpp	/^    int m_count;$/;"	m	class:Queue
m_curtime	reactor.hpp	/^    time_t m_curtime;$/;"	m	class:Reactor
m_fd	reactor.hpp	/^    int m_fd;$/;"	m	class:Reactor
m_fd	tcpaccept.hpp	/^    int m_fd;$/;"	m	class:TcpAccept
m_fd	tcpsocket.hpp	/^    int m_fd;$/;"	m	class:TcpSocket
m_front	queue.hpp	/^    int m_front;$/;"	m	class:Queue
m_handler_cnt	reactor.hpp	/^    int m_handler_cnt;$/;"	m	class:Reactor
m_handlers	reactor.hpp	/^    HandlerBase** m_handlers;$/;"	m	class:Reactor
m_head_pool	buff.hpp	/^    boost::pool<boost::default_user_allocator_malloc_free> m_head_pool;$/;"	m	class:BufPool
m_id	reactor.hpp	/^    int m_id;$/;"	m	class:Reactor
m_id	tcpsocket.hpp	/^    int m_id;$/;"	m	class:TcpSocket
m_inited	reactor.hpp	/^    bool m_inited;$/;"	m	class:Reactor
m_ip	tcpaccept.hpp	/^    sockaddr_in m_ip;$/;"	m	class:TcpAccept
m_ip	tcpsocket.hpp	/^    sockaddr_in m_ip;$/;"	m	class:TcpSocket
m_last_time	tcpsocket.hpp	/^    uint32_t m_last_time;$/;"	m	class:TcpSocket
m_local_ip	tcpsocket.hpp	/^    sockaddr_in m_local_ip;$/;"	m	class:TcpSocket
m_mutex_lock	lock.hpp	/^    pthread_mutex_t m_mutex_lock;$/;"	m	class:MutexLock
m_oldtime	reactor.hpp	/^    time_t m_oldtime;$/;"	m	class:Reactor
m_page_pool	buff.hpp	/^    boost::pool<boost::default_user_allocator_malloc_free> m_page_pool;$/;"	m	class:BufPool
m_qlist	queue.hpp	/^    T* m_qlist;$/;"	m	class:Queue
m_reactor	tcpaccept.hpp	/^    Reactor& m_reactor;$/;"	m	class:TcpAccept
m_reactor	tcpsocket.hpp	/^    Reactor& m_reactor;$/;"	m	class:TcpSocket
m_rear	queue.hpp	/^    int m_rear;$/;"	m	class:Queue
m_recvbuf	tcpsocket.hpp	/^    uint8_t* m_recvbuf;$/;"	m	class:TcpSocket
m_recvbuf_size	tcpsocket.hpp	/^    uint32_t m_recvbuf_size;$/;"	m	class:TcpSocket
m_recvpos	tcpsocket.hpp	/^    uint32_t m_recvpos;$/;"	m	class:TcpSocket
m_sendbufs	tcpsocket.hpp	/^    boost::circular_buffer<BufBlock_t*> m_sendbufs;$/;"	m	class:TcpSocket
m_sendpos	tcpsocket.hpp	/^    uint32_t m_sendpos;$/;"	m	class:TcpSocket
m_singleton	buff.cpp	/^BufPool BufPool::m_singleton;$/;"	m	class:BufPool	file:
m_singleton	buff.hpp	/^    static BufPool m_singleton;$/;"	m	class:BufPool
m_singleton	tcpsocketpool.cpp	/^TcpSocketPool TcpSocketPool::m_singleton;$/;"	m	class:TcpSocketPool	file:
m_singleton	tcpsocketpool.hpp	/^    static TcpSocketPool m_singleton;$/;"	m	class:TcpSocketPool
m_size	queue.hpp	/^    int m_size;$/;"	m	class:Queue
m_size	reactor.hpp	/^    int m_size;$/;"	m	class:Reactor
m_sk	tcpsocket.hpp	/^    Skinfo_t m_sk;$/;"	m	class:TcpSocket
m_socketPool	tcpsocketpool.hpp	/^    boost::object_pool<TcpSocket> m_socketPool;$/;"	m	class:TcpSocketPool
m_timeout	tcpaccept.hpp	/^    uint32_t m_timeout;$/;"	m	class:TcpAccept
main	main.cpp	/^int main() {$/;"	f
make_id	reactor.hpp	/^    inline int make_id() {return m_id++;}$/;"	f	class:Reactor
nDefaultQueueSize	queue.hpp	/^const int nDefaultQueueSize = 500;$/;"	v
objects	Makefile	/^objects = reactor.o main.o queue.o buff.o global_data.o tcpaccept.o tcpsocket.o tcpsocketpool.o lock.o$/;"	m
page_base	buff.hpp	/^    uint8_t *page_base;$/;"	m	struct:BufBlock_t
page_num	buff.hpp	/^    uint32_t page_num;$/;"	m	struct:BufBlock_t
pop_queue	queue.cpp	/^T Queue<T>::pop_queue() {$/;"	f	class:Queue
push_buf	tcpaccept.cpp	/^void TcpAccept::push_buf(BufBlock_t* block) {$/;"	f	class:TcpAccept
push_buf	tcpsocket.cpp	/^void TcpSocket::push_buf(BufBlock_t* block) {$/;"	f	class:TcpSocket
push_queue	queue.cpp	/^int Queue<T>::push_queue(const T& item) {$/;"	f	class:Queue
recvtm	airapi.h	/^    time_t recvtm;$/;"	m	struct:Skinfo_t
remote_ip	airapi.h	/^    uint32_t remote_ip;$/;"	m	struct:Skinfo_t
remote_port	airapi.h	/^    uint16_t remote_port;$/;"	m	struct:Skinfo_t
remove	tcpsocketpool.cpp	/^void TcpSocketPool::remove(TcpSocket* socket)$/;"	f	class:TcpSocketPool
sendtm	airapi.h	/^    time_t sendtm;$/;"	m	struct:Skinfo_t
set_handler	reactor.cpp	/^bool Reactor::set_handler(int fd, HandlerBase* handler) {$/;"	f	class:Reactor
size	queue.cpp	/^int Queue<T>::size() {$/;"	f	class:Queue
sk	buff.hpp	/^    Skinfo_t sk;$/;"	m	struct:BufHead_t
socket	airapi.h	/^    int socket;$/;"	m	struct:Skinfo_t
start	tcpaccept.cpp	/^bool TcpAccept::start(sockaddr_in &ip, uint32_t time_out) {$/;"	f	class:TcpAccept
start	tcpsocket.cpp	/^bool TcpSocket::start(int fd, sockaddr_in &ip, sockaddr_in &local_ip, uint32_t conn_timeout) {$/;"	f	class:TcpSocket
stop	main.cpp	/^volatile bool stop = false;$/;"	v
thread_tid	workthread.hpp	/^    pthread_t thread_tid;$/;"	m	struct:__anon1
tptr	workthread.hpp	/^Thread* tptr; $/;"	v
unlock	lock.cpp	/^void MutexLock::unlock() {$/;"	f	class:MutexLock
work_run	workthread.hpp	/^void* work_run(void* arg) {$/;"	f
~BufPool	buff.cpp	/^BufPool::~BufPool()$/;"	f	class:BufPool
~HandlerBase	handler.hpp	/^    virtual ~HandlerBase() {}$/;"	f	class:HandlerBase
~MutexLock	lock.cpp	/^MutexLock::~MutexLock() {$/;"	f	class:MutexLock
~Queue	queue.cpp	/^Queue<T>::~Queue() {$/;"	f	class:Queue
~Reactor	reactor.cpp	/^Reactor::~Reactor() {$/;"	f	class:Reactor
~TcpAccept	tcpaccept.cpp	/^TcpAccept::~TcpAccept() {$/;"	f	class:TcpAccept
~TcpSocket	tcpsocket.cpp	/^TcpSocket::~TcpSocket() {$/;"	f	class:TcpSocket
~TcpSocketPool	tcpsocketpool.cpp	/^TcpSocketPool::~TcpSocketPool(){$/;"	f	class:TcpSocketPool
